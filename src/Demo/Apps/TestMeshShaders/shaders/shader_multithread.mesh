#version 450
#extension GL_NV_mesh_shader : require
#extension GL_ARB_separate_shader_objects : require
#extension GL_NV_gpu_shader5 : enable


#define THREAD_COUNT 32


layout(local_size_x=THREAD_COUNT, local_size_y=1, local_size_z=1) in;
layout(triangles, max_vertices=64, max_primitives=126) out;


// -------------------Output data ----------------------------
out gl_PerVertex
{
    vec4 gl_Position;
} gl_stupid;

out gl_MeshPerVertexNV 
{
     vec4 gl_Position;
} gl_MeshVerticesNV[];

out uint gl_PrimitiveCountNV;
out uint gl_PrimitiveIndicesNV[];

out perVertexData 
{  
    vec3 color;
} customData[64];


// --------------------- Structures ------------------------------
struct Vertex
{
    float x;
    float y;
    float z;
};

struct Meshlet
{
    uint32_t vertices[64];      
    uint32_t indices[126 * 3];
    uint32_t triangleCount;
    uint32_t vertexCount;
};


// --------------------- SSBO buffers -----------------------------
layout(binding = 0, shared) readonly buffer vertices_ssbo
{
    Vertex vertices[];
} vertex_buffer;

layout(binding = 2, shared) readonly buffer meshlets_ssbo
{
	Meshlet meshlets[];
} meshlet_buffer;

// --------------------- Uniforms ---------------------------------
//uniform mat4 u_M_matrix;
//uniform mat4 u_VP_matrix;
uniform mat4 u_MVP_matrix;
uniform uint u_meshlet_index;


uint hash(uint a)
{
   a = (a+0x7ed55d16) + (a<<12);
   a = (a^0xc761c23c) ^ (a>>19);
   a = (a+0x165667b1) + (a<<5);
   a = (a+0xd3a2646c) ^ (a<<9);
   a = (a+0xfd7046c5) + (a<<3);
   a = (a^0xb55a4f09) ^ (a>>16);
   return a;
}

vec3 calculate_meshlet_color(uint meshlet_index)
{
    uint mhash = hash(gl_WorkGroupID.x);
    vec3 mcolor = vec3(float(mhash & 255), float((mhash >> 8) & 255), float((mhash >> 16) & 255)) / 255.0;
    return mcolor;
}


void main()
{
    uint mi = uint(gl_WorkGroupID.x);               // meshlet index
    uint ti = uint(gl_LocalInvocationID.x);         // thread index

    // process vertices
    for (uint i = ti; i < meshlet_buffer.meshlets[mi].vertexCount; i += THREAD_COUNT)
    {
        float x = vertex_buffer.vertices[meshlet_buffer.meshlets[mi].vertices[i]].x;
        float y = vertex_buffer.vertices[meshlet_buffer.meshlets[mi].vertices[i]].y;
        float z = vertex_buffer.vertices[meshlet_buffer.meshlets[mi].vertices[i]].z;

        vec4 position = vec4(x, y, z, 1.0);

        position = u_MVP_matrix * position;

        gl_MeshVerticesNV[i].gl_Position = position;
        customData[i].color = calculate_meshlet_color(mi);
    }

    // process indices
    for (uint i = ti; i < meshlet_buffer.meshlets[mi].triangleCount * 3; i += THREAD_COUNT)
    {
        gl_PrimitiveIndicesNV[i] = meshlet_buffer.meshlets[mi].indices[i];
    }

    if (ti == 0)
    {
        gl_PrimitiveCountNV = meshlet_buffer.meshlets[mi].triangleCount;
    }
}

